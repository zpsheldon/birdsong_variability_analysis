function [w,D,d,dist]=dtwDist(x,y,pthwt,bndfct,xvarmat,yvarmat)
% function [w,D,d,dist]=dtwDist(x,y,pthwt,xvarmat,yvarmat)
% DTW function using Euclidean distance, based on algorithm in Rabiner 
% and Juang (1993)
%
% pthwt: path weighting. default [1.5,1.5,1] is least biased.
% bndfct: restricts path to inner-bdnfct map diagonals (Sakoe-Chiba band)
%
% xvarmat and yvarmat: matrices of variance that can be fed to distMat
% and cut down in processing time if analyzing distances from the same
% spectrogram
%
% w: DTW map, first column is time index of x, forced to increase in
% single steps, 2nd column is time index of y
%
% D: cumulative distance matrix as described in Rabiner and Juang (1993)
% d: matrix if pairwise distances among columns of x and y
% dist: average Euclidean distance between x and time-warped y

[rows,N]=size(x);
[rows,M]=size(y);

if nargin < 3
    pthwt = [1 1.5 1.5];
end

if nargin < 4
    bndfct = 1/3;
end

%distance matrix. xvarmat is optional sum of squares for x (generated by
%distMat if not given)
if nargin < 5
    d = distMat(x,y);
elseif nargin < 6
    d = distMat(x,y,xvarmat);
else
    d = distMat(x,y,xvarmat,yvarmat);
end

nlim = round(N*bndfct);
mlim = round(M*bndfct);

% to avoid needing an arbitrary limit to distance, strategy is to use 
% negative of d (forced to be all positive) and maximize score 
dneg = -(d-max(d(:)));

% cumulative score matrix
D = mkCumScr(dneg,pthwt,M,N,mlim,nlim);

% [i,j] = ind2sub([N,M],1:numel(D));

% find starting point in maximum along end of map
% inds = find(i==N | j ==M);
% [dmy,maxind] = max(D(inds));
% n=i(inds(maxind));
% m=j(inds(maxind));

[i,j] = find(D);
inds = find(i==N | j ==M);
Dvals = D(sub2ind(size(D),i,j));
[dmy,maxind] = max(Dvals(inds));
n=i(inds(maxind));
m=j(inds(maxind));

k=1;

% path tracing, stored in w
w = zeros(N+M,2);
w(1,:)=[n,m];

while n > 2 && m > 2
    
    P1 = dneg(n,m);
    P2 = .5*dneg(n,m) + .25*dneg(n-1,m) + .25*dneg(n-1,m-1);
    P3 = .5*dneg(n,m) + .25*dneg(n,m-1) + .25*dneg(n-1,m-1);
    
    pts = [D(n-1,m-1),D(n-2,m-1),D(n-1,m-2)];
    pthset = pts + [P1,P2,P3] .* pthwt;
    
    [values,number] = max(pthset);
    
    k=k+1;
    
    switch number
        
        case 1
            n=n-1;
            m=m-1;
            w(k,:) = [n,m];
            
            
        case 2
            
            n=n-1;
            m=m-.5;
            w(k,:) = [n,m];
            
            k=k+1;
            n=n-1;
            m=m-.5;
            w(k,:) = [n,m];
            
        case 3
            
            n=n-1;
            m=m-2;
            w(k,:) = [n,m];
            
            
            
    end
    
    
    
end


% calculate endings. max/min functions not used above in order to save
% processing time.

if w(k,1)>1 && w(k,2)>1
    
    if w(k,1)==2 && w(k,2)==2
        k = k+1;
        
        n = n-1;
        m = m-1;
        w(k,:) = [n,m];
        
    elseif w(k,1)==2
        
        P1 = dneg(n,m);
        P2 = .5*dneg(n,m) + .25*dneg(n,m-1) + .25*dneg(n-1,m-1);
        
        pts = [D(n-1,m-1),D(n-1,m-2)];
        pthset = pts + [P1,P2] .* pthwt(1:2);
        
        [values,number] = max(pthset);
        
        k=k+1;
        
        switch number
            
            case 1
                n=n-1;
                m=m-1;
                w(k,:) = [n,m];
                
            case 2
                n=n-1;
                m=m-2;
                w(k,:) = [n,m];
                
        end
        
    else
        
        P1 = dneg(n,m);
        P3 = .5*dneg(n,m) + .25*dneg(n-1,m) + .25*dneg(n-1,m-1);
        
        pts = [D(n-1,m-1),D(n-2,m-1)];
        pthset = pts + [P1,P3] .* pthwt([1 3]);
        
        [values,number] = max(pthset);
        
        k=k+1;
        
        switch number
            case 1
                n=n-1;
                m=m-1;
                w(k,:) = [n,m];
                
                
            case 2
                n=n-1;
                m=m-.5;
                w(k,:) = [n,m];
                
                k=k+1;
                n=n-1;
                m=m-.5;
                w(k,:) = [n,m];
                
                
        end
        
    end
    
end

w = w(1:k,:);

if nargout == 4  
    dist = sqrt(sum(d(sub2ind(size(d),round(w(:,1)),round(w(:,2))))) / (size(x,1)*size(w,1)));
end